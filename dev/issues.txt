Engine:
- Allow optional planes per node, upon the first time I need it.
- Might want to make units more readable for vl and vr.
- Are defaults injected in the right places?  Probably not, given that object spread is the single biggest performance hog.  Much less of a problem now that I cache the fitted moes.
- Should extend() wrap around?
- Try to move all the "tinify" logic to very temporary places.
	- I removed all tinification except for angle$spherify...do things work now?
	- I left it in there for sphere$vectorize as well.  Vectors are rarely displayed directly, except as planes, so it shouldn't be much distraction.

Apps:
- Integrate it with React.
- Add the exhibit in once I first need it.
- Would be nice if we could export this stuff in a way that's actually kind of spinnable.

Bugs:
- TWIST still looks wrong in parts of WHXFL plane.
- Fan-based toroids flicker in certain spots, which may be related to the above.
- All breaks in angle$spherify are gone, but are there maybe still cusps?
- The refitting approach I used to save the comborific.json got a few things wrong, including twist and a handful of positions.

- It seems like prop.toXYZ and move.toXYZ might be good things, 


React App:
	Core:
	- The conform-vs-fits issue is actually a really thorny one.
	- +s to add props.  -s?
	- Add color changing?
		- Could do via right-click?
	- locks shouldn't be allowed when r is not zero.

	Nice:
	- Make sure all panel elements work.
	- Make sure you can't modify the first move.
	- Better player controls.
		- Should block / alter use of some / most other controls?
		- Might need to override / wrap existing onclicks;
		- Should it start at current tick?
	- Make it so you can change prop colors.
	- A few planes are backwards.
	- Maybe make the different nodes look different.
	- Get icons from noun project for viewing angle.
	- Would be nice if SVGs rendered according to depth.
	- Might want to remove default properties when exporting.
	- Have the import do resolving and validating.


	Solving the node-sum problem:
	- Toggleable manipulation of beginning nodes.
		- Head and hand stay frozen...does that work?
	- Smart defaults, auto-back-propagating?
		- Algorithm
			- Try extending the ending non-zero abstract nodes backwards.
			- Try zeroing out combinations of other abstract nodes in some order to find fits()
				- Doesn't guarantee a solution, but might usually.

	- Okay, finally we managed to produce the problem!  We verified that the approach I was using doesn't work.
	- So what's next?  I feel like the algorithm is the only great idea I have right now.
		- Need to write and test the algorithm.
		- The inverse propnode approach doesn't really work here, does it?
			- So you've got it set up right, then you move something, and move it back.  Does the inverse propnode survive?  No, not unless you're using the algorithm.
