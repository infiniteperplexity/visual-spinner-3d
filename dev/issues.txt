Engine:
- Allow optional planes per node, upon the first time I need it.
- Are defaults injected in the right places?  Probably not, given that object spread is the single biggest performance hog.  Much less of a problem now that I cache the fitted moes.
- linear movement is now broken and I barely care to fix it.
- not sure if radial acceleration units are correct

Apps:
- Integrate it with React.
- Add the exhibit in once I first need it.
- Would be nice if we could export this stuff in a way that's actually kind of spinnable.

Bugs:
- TWIST still looks wrong in parts of WHXFL plane.
- Fan-based toroids flicker in certain spots, which may be related to the above.
- All breaks in angle$spherify are gone, but are there maybe still cusps?
- The refitting approach I used to save the comborific.json got a few things wrong, including twist and a handful of positions.

- It seems like prop.toXYZ and move.toXYZ might be good things, 


React App:
	Core:
	- The conform-vs-fits issue is actually a really thorny one.
	- +s to add props.  -s?
	- locks shouldn't be allowed when r is not zero.
	- change how linear and radial speeds look

	Nice:
	- Make sure all panel elements work.
	- Make sure you can't modify the first move.
	- Better player controls.
		- Should block / alter use of some / most other controls?
		- Should it start at current tick?
	- Make it so you can change prop colors.
	- Might want to remove default properties when exporting.
	- Have the import do resolving and validating.
	- Make looking at a move in the wrong plane more sensible.


	Solving the node-sum problem:
	- Toggleable manipulation of beginning nodes.
		- Head and hand stay frozen...does that work?
	- Smart defaults, auto-back-propagating?
		- Algorithm
			- Try extending the ending non-zero abstract nodes backwards.
			- Try zeroing out combinations of other abstract nodes in some order to find fits()
				- Doesn't guarantee a solution, but might usually.

	- Okay, finally we managed to produce the problem!  We verified that the approach I was using doesn't work.
	- So what's next?  I feel like the algorithm is the only great idea I have right now.
		- Need to write and test the algorithm.
		- The inverse propnode approach doesn't really work here, does it?
			- So you've got it set up right, then you move something, and move it back.  Does the inverse propnode survive?  No, not unless you're using the algorithm.

	- Algorithm can't distinguish static stretches from spirals if one end of the move is at zero.
		- Could have a checkbox to distinguish.
		- Could always assume spiral for head and static for everything else.



