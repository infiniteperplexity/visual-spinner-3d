<!--Distributed under GNU Public License version 3-->
<!DOCTYPE html>
<html><head>
<style>
body {margin: 0; padding: 0; background-color: #679}
h1, h2, header p {text-align: center}
header {width: 1240px; height: 100px}
#content {width: 1250px; height: 510px;}
section {margin: 0; padding: 0}
header, section div {vertical-align: top; padding: 2.5px; border: 5px solid gray; margin: -2.5px; display: inline-block;}
#display {width: 400px; height: 400px; float: left}
#control {position: absolute; top: 520px; left: 0; height: 90px; width: 400px;}
.queue, #menu, #workshop {width: 200px; height: 500px; float: left}
canvas {width: 400px; height: 400px; background-color: #000;}
.queue h2, #menu h2, #workshop h2 {height: 25px; text-decoration: underline}
.queue select {width: 200px; height: 400px;}
#menu select {width: 200px; height: 430px;}
#workshop select {width: 199px; height: 380px;}
table {position: relative; top: -20px;}
#popexport {position: fixed; z-index: 1; top: 150px; left: 50px; }
#popimport {position: fixed; z-index: 1; top: 150px; left: 50px;}
#popalign1 {position: fixed; z-index: 1; top: 250px; left: 420px; background-color: #FFF; padding: 2.5px; border: 5px solid gray; margin: -2.5px;}
#popalign2 {position: fixed; z-index: 1; top: 250px; left: 630px; background-color: #FFF; padding: 2.5px; border: 5px solid gray; margin: -2.5px;}
#radius1, #radius2 {width: 50px;}
#frameN {width: 100px;}
#movemodify {position: fixed; z-index: 1; top: 150px; left: 550px; width: 400px; background-color: #FFF; padding: 2.5px; border: 5px solid gray; margin: -2.5px;};
</style>


<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>VisualSpinner3D Composer, by Glenn Wright</title>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="scripts/gl-matrix-min.js"></script>
<script src="scripts/phoria-min.js"></script>
<script src="scripts/requestAnimationFrame.js"></script>
<script src="scripts/visual-spinner-engine.js"></script>
<script src="scripts/visual-spinner-moves.js"></script>
<script src="scripts/visual-spinner-renderers.js"></script>
<script src="scripts/visual-spinner-recipes.js"></script>
<script>

//**** set parameters and set up environment and display
var HEIGHT = 400;
var WIDTH = 400;
var ORIGINX = WIDTH/2;
var ORIGINY = HEIGHT/2;
var BACKGROUND = "black";
var view2d = false;
var myProps = new Array(); 
var moves = new MoveFactory();
var props = new PropFactory();
var scene = new Phoria.Scene();
var renderer;
var predictions = [props.poi({head_color: "0,32,64", scene: scene}),props.poi({head_color: "64,0,0", scene: scene})];
var propOne = props.poi({head_color: "blue", flame_color: "blue", scene: scene});
var propTwo = props.poi({head_color: "red", flame_color: "red", scene: scene});
var startingPositions = [props.noprop({scene: scene}),props.noprop({scene: scene})];
function canvasSetup() {
	var canvas = document.getElementById("canvas");
	window.addEventListener("keydown", listenForKey, false);
	// set up Phoria scene for 3D rendering
	scene.camera.position = {x:0.0, y:1.0, z:10.0};
	scene.perspective.aspect = canvas.width / canvas.height;
	scene.viewport.width = canvas.width;
	scene.viewport.height = canvas.height;
	renderer = new Phoria.CanvasRenderer(canvas);
	var plane = Phoria.Util.generateTesselatedPlane(8,8,0,20);
	scene.graph.push(Phoria.Entity.create({
		points: plane.points,
		edges: plane.edges,
		polygons: plane.polygons,
		style: {
				 drawmode: "wireframe",
				 shademode: "plain",
				 linewidth: 0.5,
				 objectsortmode: "back"
			}}));
	scene.graph.push(new Phoria.DistantLight());
	var light = new Phoria.DistantLight();
	light.direction.x = 1;
	light.direction.z = 0;
	scene.graph.push(light);
	light = new Phoria.DistantLight();
	light.direction.y = 1;
	light.direction.z = 0;
	scene.graph.push(light);
	// set up props
	propOne.hand.radius = 1;
	propTwo.hand.radius = 1;
	propOne.rotateHand(SPLIT);
	propOne.rotateProp(SPLIT);
	myProps.push(propOne);
	myProps.push(propTwo);
	startingPositions[0].orientToProp(propOne);
	startingPositions[1].orientToProp(propTwo);
	predictions[0].orientToProp(propOne);
	predictions[1].orientToProp(propTwo);
	predictions[0].nudge(-0.1,0,-0.1);
	predictions[1].nudge(0.1,0,-0.1);
	redraw();
}
window.addEventListener("keydown", listenForKey, false);
Prop.prototype.spinfail = function() {
	alert("can't spin with an empty queue");
}

//**** animation and rendering
function canvasLoop() {
	if (paused == true) {return;}
	setTimeout(function() {
		requestAnimationFrame(canvasLoop);
		redraw();
		for (var i = 0; i < myProps.length; i++) {
			if (myProps[i].move.getDuration() === 0) {
				alert("Can't spin with an empty queue.");
				paused = true;
				return;
			}
		}
		advanceFrames(1);
		for (var i = 0; i < myProps.length; i++) {
			myProps[i].render();
		}
	},1000/BEAT);
}
function redraw() {
	for (var i = 0; i < myProps.length; i++) {
		predictions[i].render();
		myProps[i].render();
	}
	scene.modelView();
	renderer.render(scene);
}

//**** on load
function init() {
	$("#popexport").hide();
	$("#popimport").hide();
	populateMenu();
	canvasSetup();
}
function populateMenu() {
	var menu = $("#menu").children("select");
	var option;
	for (var key in recipes) {
		if (key !== "add") {
			option = '<option draggable="true" ondragstart="dragMenu(event)" value="'+key+'">'+key+"</option>";
			menu.append(option);
		}
	}
}


//**** handle drag and drop events
function allowDrop(event) {
	event.preventDefault();
}
function dragMenu(event) {
	var movename = event.target.text;
	//event.dataTransfer.setData("Text", movename);
	event.dataTransfer.setData("Text", JSON.stringify(recipes[movename]));
}
function dropQueue(event) {
	event.preventDefault();
	//var movename = event.dataTransfer.getData("Text");
	//var build = JSON.stringify(recipes[movename]);
	var definition= event.dataTransfer.getData("Text");
	addMoveToQueue(definition, event.target);
}
function addMoveToQueue(definition, target) {
	var move = moves.build(definition);
	var prop;
	var queue = target.parentNode.id;
	if (queue === "queue1") {
		prop = propOne;
	} else if (queue === "queue2") {
		prop = propTwo;
	}
	if (move.adjust(prop) != null) {
		var child = document.createElement("option");
		child.text = JSON.parse(definition).movename;
		child.value = definition;
		//child.draggable = true;
		//child.addEventListener('dragstart',drag);
		target.appendChild(child);
		prop.addMove(move);
		//sloppy programming...
		if (prop==propOne) {
			predictions[0].orientToProp(propOne.predict());
			predictions[0].nudge(-0.1,0,-0.1);
		} else if (prop==propTwo) {
			predictions[1].orientToProp(propTwo.predict());
			predictions[1].nudge(0.1,0,-0.1);
		}
	}
	var max;
	for (var i = 0; i < myProps.length; i++) {
		max = Math.max(myProps[i].move.getDuration()*BEAT);
	}
	document.getElementById("frameN").setAttribute("max", max.toString());
	redraw();
}
function dragWorkshop(event) {
	var definition = event.target.value;
	//event.dataTransfer.setData("Text", movename);
	event.dataTransfer.setData("Text", definition);
}
function dropWorkshop(event) {
	event.preventDefault();
	var target = event.target;
	if (target.parentNode != null && target.parentNode.id === "thisMove") {target = target.parentNode;}
	var child = document.createElement("option");
	child.value = event.dataTransfer.getData("Text");
	child.text = JSON.parse(child.value).movename;
	child.draggable = true;
	child.addEventListener('dragstart',dragWorkshop);
	child.addEventListener('dragover', allowDrop);
	child.addEventListener('dblclick', modifyMove);
	//target.replaceChild(child, target.childNodes[0]);
	target.appendChild(child);
	//document.getElementById("json").value = JSON.stringify(recipes[child.text], null, '\n');
}

//**** placeholder functionality
function nothing() {
	alert("not yet implemented");
}

var moveTarget;

function modifyMove(event) {
	moveTarget = event.target;
	$("#moveinner").empty();
	$("#movemodify").toggle();
	var definition = moves.parse(event.target.value);
	addInput(textInput(definition,"movename"));
	addInput(textInput(definition,"build"));
	addInput(selectInput(definition,"spin",["In-Spin","Anti-Spin"],[INSPIN, ANTISPIN]));
	addInput(numberInput(definition,"duration",[0.25,2,0.25]));
	addInput(selectInput(definition,"orient",["Up","Right","Down","Left"],[TWELVE, THREE, SIX, NINE]));
	addInput(selectInput(definition,"entry",["Up","Right","Down","Left"],[TWELVE, THREE, SIX, NINE]));
	addInput(selectInput(definition,"direction",["Clockwise","Counter"],[CLOCKWISE, COUNTERCLOCKWISE]));
	addInput(numberInput(definition,"extend",[0,1,0.5]));
	addInput(selectInput(definition,"petals",["Zero","One", "Two", "Three", "Four"],[0,1,2,3,4]));
	addInput(selectInput(definition,"mode",["Diamond","Box"],[DIAMOND, BOX]));
}

function addInput(inpt) {
	if (inpt === null) {return;}
	var popup = document.getElementById("moveinner");
	var txt = document.createElement("span");
	txt.innerHTML = inpt.getAttribute("data-param")+": ";
	popup.appendChild(document.createElement("br"));
	popup.appendChild(txt);
	popup.appendChild(inpt);	
}
function textInput(definition, parameter) {
	if (definition[parameter]===undefined) {return null;}
	var inpt = document.createElement("input");
	inpt.type = "text";
	inpt.value = definition[parameter];
	inpt.setAttribute("data-param",parameter);
	return inpt;
}
function numberInput(definition, parameter, arr) {
	if (definition[parameter]===undefined) {return null;}
	var inpt = document.createElement("input");
	inpt.type = "number";
	inpt.min = arr[0].toString();
	inpt.max = arr[1].toString();
	inpt.step = arr[2].toString();
	inpt.value = definition[parameter].toString();
	inpt.setAttribute("data-param",parameter);
	return inpt;
}
function selectInput(definition, parameter, arr, vals) {
	if (definition[parameter]===undefined) {return null;}
	var inpt = document.createElement("select");
	var optn;
	for (var i = 0; i< arr.length; i++) {
		optn = document.createElement("option");
		optn.text = arr[i];
		optn.value = vals[i].toString();
		if (nearly(definition[parameter],vals[i])) {
			optn.selected = true;
		}
		inpt.appendChild(optn);
	}
	inpt.setAttribute("data-param",parameter);
	return inpt;
}

function isNumber(n) {
	return !isNaN(parseFloat(n)) && isFinite(n);
}
function submitChanges() {
	var move = moveTarget;
	var olddef = moves.parse(move.value);
	var newdef = {};
	var inputs = $("#moveinner").children().toArray();
	var param;
	for (var i = 0; i < inputs.length; i++) {
		if (inputs[i] instanceof HTMLInputElement || inputs[i] instanceof HTMLSelectElement) {
			param = inputs[i].getAttribute("data-param");
			newdef[param] = inputs[i].value;
			if (isNumber(newdef[param])) {
				newdef[param] = parseFloat(newdef[param]);
			}
		}
	}
	for (var p in newdef) {
		olddef[p] = newdef[p];
	}
	move.value = JSON.stringify(olddef);
	move.text = olddef.movename;
	$("#movemodify").toggle();
}

// animation loop
var paused = false;
function startSpin() {
	paused = false;
	canvasLoop();
}

function pauseSpin() {
	paused = true;
}

function spinFrames(n) {
	if (n > 0) {
		pauseSpin();
		advanceFrames(n);
	} else if (n < 0) {
		var value = parseInt(document.getElementById("frameN").value);
		totalReset();
		// This nonsense is necessary because it currently sometimes spins one additional frame after resetting
		advanceFrames(value + n - parseInt(document.getElementById("frameN").value));
	}
	for (var i = 0; i < myProps.length; i++) {
		myProps[i].render();
	}
	redraw();
}

function totalReset() {
	pauseSpin();
	document.getElementById("frameN").value = "0";
	for (var i= 0; i < myProps.length; i++) {
		myProps[i].move.reset();
		myProps[i].orientToProp(startingPositions[i]);
	}
	redraw();
}

function listenForKey(e) {
	//alert(e.keyCode);
	if (e.keyCode ===13) {
		if (document.activeElement == document.getElementById("frameN")) {
			goToFrame();
		}
	} else if (e.keyCode===37) {
		spinFrames(-12);
	} else if (e.keyCode===39) {
		spinFrames(12);
	} else if (e.keyCode==8 || e.keyCode == 46) {
		if (document.activeElement.parentNode.className=="queue") {
			document.activeElement.removeChild(document.activeElement.lastChild);
			if(document.activeElement.parentNode.id == "queue1" && propOne.move.submoves.length > 0) {
				propOne.move.submoves.pop();
			} else if (document.activeElement.parentNode.id == "queue2" && propTwo.move.submoves.length > 0) {
				propTwo.move.submoves.pop();
			}
		} else if (document.activeElement.parentNode.id=="workshop") {
			document.activeElement.removeChild(document.activeElement.childNodes[document.activeElement.selectedIndex]);
		}
	}
}

// currently this doesn't actually check the lower bound
function checkBounds(n) {
	var max = document.getElementById("frameN").max;
	if (max==0) {
		alert("bad max input value");
		return 0;
	}
	if (n > max) {
		frameN.value = max.toString();
		while (n > max) {
			n = n-max;
		}
	} else if (n < 0) {
		alert("You entered a negative frame number and I haven't done error handling for that yet.");
	}
	return n;
}
function goToFrame() {
	var value = parseInt(document.getElementById("frameN").value);
	value = checkBounds(value);
	totalReset();
	advanceFrames(value);
	redraw();
}

function advanceFrames(n) {
	var frameN = document.getElementById("frameN");
	frameN.value = checkBounds((parseInt(frameN.value) + n)).toString();
	for (var i = 0; i < n; i++) {
		for (var j = 0;  j < myProps.length; j++) {
			myProps[j].spin();
		}
	}
}

function emptyQueues() {
	$("#queue1 select").empty();
	$("#queue2 select").empty();
	propOne.emptyMoves();
	propTwo.emptyMoves();
	totalReset();
}

//**** functionality for JSON export/import
function popExport() {
	$("#popimport").hide();
	$("#popexport").toggle();
	var red = propOne.stringify();
	var blue = propTwo.stringify();
	$("#popexport textarea").html('{"red": '+red+', "blue": '+blue+"}");
}
function popImport() {
	$("#popexport").hide();
	$("#popimport").toggle();
}
function popAlign(n) {
	$("#popalign"+n).toggle();
	var hand = $('input[name=hand1]').toArray();
	var handangle = propOne.getHandAngle();
	for (var i = 0; i < hand.length; i++) {
		if (nearly(parseFloat(hand[i].value),handangle)) {
			hand[i].checked = true;
		} else {
			hand[i].checked = false;
		}
	}
	hand = $('input[name=hand2]').toArray();
	handangle = propTwo.getHandAngle();
	for (var i = 0; i < hand.length; i++) {
		if (nearly(parseFloat(hand[i].value),handangle)) {
			hand[i].checked = true;
		} else {
			hand[i].checked = false;;
		}
	}
	var prop = $('input[name=prop1]').toArray();
	var	propangle = propOne.getPropAngle();
	for (var i = 0; i < prop.length; i++) {
		if (nearly(parseFloat(prop[i].value),propangle)) {
			prop[i].checked = true;
		} else {
			prop[i].checked = false;
		}
	}
	prop = $('input[name=prop2]').toArray();
	propangle = propTwo.getPropAngle();
	for (var i = 0; i < prop.length; i++) {
		if (nearly(parseFloat(prop[i].value),propangle)) {
			prop[i].checked = true;
		} else {
			prop[i].checked = false;
		}
	}
}

function importSubmit() {
	var imported = $("#popimport textarea").val();
	imported = props.parse(imported);
	emptyQueues();
	var newoption;
	var plane;
	for (var i = 0; i < imported.red.moves.length; i++) {
		addMoveToQueue(JSON.stringify(imported.red.moves[i]), $("#queue1 select").get(0));
	}
	for (var i = 0; i < imported.blue.moves.length; i++) {
		addMoveToQueue(JSON.stringify(imported.blue.moves[i]), $("#queue2 select").get(0));
	}
	$("#popimport").toggle();
}
function alignSubmit(n) {
	var prop;
	if (n===1) {
		prop = propOne;
	} else if (n===2) {
		prop = propTwo;
	}
	prop.setHandAngle(parseFloat($('input[name=hand' + n + ']:checked').val()));
	prop.hand.radius = parseFloat(document.getElementById('radius'+n).value);
	prop.setPropAngle(parseFloat($('input[name=prop' + n + ']:checked').val()));
	predictions[0].orientToProp(propOne);
	predictions[1].orientToProp(propTwo);
	predictions[0].nudge(-0.1,0,-0.1);
	predictions[1].nudge(0.1,0,-0.1);
	redraw();
	$("#popalign"+n).toggle();
}

</script>
</head>
<body onload="init();">
<header>
	<h1>Welcome to VisualSpinner3d. </h1>
	<p>(This interface is still in development.  Mess around all you want, but weird sh*t <em>will</em> happen.)</p>
</header>
	
<div id="content">
	<section>
		<div id="display">
			<canvas width="400" height="400" id="canvas">
				Your browser doesn't support the HTML5 element canvas.
			</canvas>
		</div>
		<div id="control">
			<button type="button" onclick="startSpin();">Play</button>
			<button type="button" onclick="pauseSpin();">Pause</button>
			<button type="button" onclick="spinFrames(-12)">-</button>
			<input id="frameN" min="0" value="0" type="number">
			<button type="button" onclick="spinFrames(12)" ;="">+</button>
			<button type="button" onclick="totalReset();">Reset Spin</button>
			<br>
			<button type="button" onclick="emptyQueues();">Reset Queues</button>
			<br>
			<button type="button" onclick="popExport();">Export to JSON</button>
			<button type="button" onclick="popImport();">Import from JSON</button>
		</div>
		<div id="queue1" class="queue">
			<h2>Blue Prop</h2>
			<button type="button" onclick="popAlign(1);">Starting Position</button>
			<select size="2" ondrop="dropQueue(event)" ;="" ondragover="allowDrop(event);"></select>
		</div>	

		<div id="queue2" class="queue">
			<h2>Red Prop</h2>
			<button type="button" onclick="popAlign(2);">Starting Position</button>
			<select size="2" ondrop="dropQueue(event);" ondragover="allowDrop(event);"></select>
		</div>
		
		<div id="workshop" ondrop="dropWorkshop(event);" ondragover="allowDrop(event);">
			<h2>Workshop</h2>
			<br>
			<select id="thisMove" size="2"></select>
			<button type="button" onclick="nothing();">Save</button>
		</div>
		
		<div id="menu">
			<h2>Menu</h2>
			<select size="2"></select>
		</div>				
	</section>
</div>
<div style="display: none;" id="popexport">
	<textarea rows="4" cols="50"></textarea><br>
	<button type="button" onclick="$('#popexport').toggle()">Done</button>
</div>
<div style="display: none;" id="popimport">
	<textarea rows="4" cols="50"></textarea><br>
	<button type="button" onclick="popImport();">Cancel</button>
	<button type="button" onclick="importSubmit();">Submit</button>
</div>
<div style="display: none;" id="popalign1">
	Hand:
				</p><table>
					<tbody><tr>
						<td></td>
						<td><input name="hand1" value="4.712389" type="radio">Up</td>
						<td></td>
					</tr>
					<tr>
						<td><input checked="checked" name="hand1" value="3.141593" type="radio">Left</td>
						<td><input id="radius1" min="0" max="1" step="0.5" value="1" type="number"></td>
						<td><input name="hand1" value="0" type="radio">Right</td>
					</tr>	
					<tr>
						<td></td>
						<td><input name="hand1" value="1.570796" type="radio">Down</td>
						<td></td>
					</tr>	
				</tbody></table>	
				Prop:
				<table>
					<tbody><tr>
						<td></td>
						<td><input name="prop1" value="4.712389" type="radio">Up</td>
						<td></td>
					</tr>
					<tr>
						<td><input checked="checked" name="prop1" value="3.141593" type="radio">Left</td>
						<td></td>
						<td><input name="prop1" value="0" type="radio">Right</td>
					</tr>	
					<tr>
						<td></td>
						<td><input name="prop1" value="1.570796" type="radio">Down</td>
						<td></td>
					</tr>	
				</tbody></table>
	<button type="button" onclick="popAlign(1);">Cancel</button>
	<button type="button" onclick="alignSubmit(1);">Submit</button>
</div>
<div style="display: none;" id="popalign2">
		Hand:
				</p><table>
					<tbody><tr>
						<td></td>
						<td><input name="hand2" value="4.712389" type="radio">Up</td>
						<td></td>
					</tr>
					<tr>
						<td><input checked="checked" name="hand2" value="3.141593" type="radio">Left</td>
						<td><input id="radius2" min="0" max="1" step="0.5" value="1" type="number"></td>
						<td><input name="hand2" value="0" type="radio">Right</td>
					</tr>	
					<tr>
						<td></td>
						<td><input name="hand2" value="1.570796" type="radio">Down</td>
						<td></td>
					</tr>	
				</tbody></table>	
		Prop:
				<table>
					<tbody><tr>
						<td></td>
						<td><input name="prop2" value="4.712389"" type="radio">Up</td>
						<td></td>
					</tr>
					<tr>
						<td><input checked="checked" name="prop2" value="3.141593" type="radio">Left</td>
						<td></td>
						<td><input name="prop2" value="0" type="radio">Right</td>
					</tr>	
					<tr>
						<td></td>
						<td><input name="prop2" value="1.570796" type="radio">Down</td>
						<td></td>
					</tr>	
				</tbody></table>
	<button type="button" onclick="popAlign(2);">Cancel</button>
	<button type="button" onclick="alignSubmit(2);">Submit</button>
</div>
<div style="display: none;" id="movemodify">
	<button type="button" onclick='$("#movemodify").toggle();'>Cancel</button>
	<button type="button" onclick="submitChanges();">Submit</button>
	<div id="moveinner"></div>
</div>
</body></html>