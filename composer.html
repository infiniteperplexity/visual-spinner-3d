<!--Distributed under GNU Public License version 3-->
<!DOCTYPE html>
<html><head>
<style>
body {margin: 0; padding: 0; background-color: #679}
h1, h2, header p {text-align: center}
header {width: 1240px; height: 100px}
#content {width: 1250px; height: 510px;}
section {margin: 0; padding: 0}
header, section div {vertical-align: top; padding: 2.5px; border: 5px solid gray; margin: -2.5px; display: inline-block;}
#display {width: 400px; height: 400px; float: left}
#control {position: absolute; top: 520px; left: 0; height: 90px; width: 400px;}
.queue, #menu, #workshop {width: 200px; height: 500px; float: left}
canvas {width: 400px; height: 400px; background-color: #000;}
.queue h2, #menu h2, #workshop h2 {height: 25px; text-decoration: underline}
.queue select {width: 200px; height: 400px;}
#menu select {width: 200px; height: 430px;}
#workshop select {width: 199px; height: 380px;}
table {position: relative; top: -20px;}
#popexport {position: fixed; z-index: 1; top: 150px; left: 50px; }
#popimport {position: fixed; z-index: 1; top: 150px; left: 50px;}
#popalign1 {position: fixed; z-index: 1; top: 100px; left: 420px; background-color: #FFF; padding: 2.5px; border: 5px solid gray; margin: -2.5px;}
#popalign2 {position: fixed; z-index: 1; top: 100px; left: 630px; background-color: #FFF; padding: 2.5px; border: 5px solid gray; margin: -2.5px;}
#radius1, #radius2 {width: 50px;}
#frameN {width: 100px;}
#movemodify {position: fixed; z-index: 1; top: 150px; left: 550px; width: 400px; background-color: #FFF; padding: 2.5px; border: 5px solid gray; margin: -2.5px;};
</style>


<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>VisualSpinner3D Composer, by Glenn Wright</title>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="scripts/gl-matrix-min.js"></script>
<script src="scripts/phoria-min.js"></script>
<script src="scripts/requestAnimationFrame.js"></script>
<script src="scripts/visual-spinner-engine.js"></script>
<script src="scripts/visual-spinner-moves.js"></script>
<script src="scripts/visual-spinner-renderers.js"></script>
<script src="scripts/visual-spinner-recipes.js"></script>

<script>
"use strict";
//**** set parameters and set up environment and display
var HEIGHT = 400;
var WIDTH = 400;
var ORIGINX = WIDTH/2;
var ORIGINY = HEIGHT/2;
var BACKGROUND = "black";
var view2d = false;
var myProps = new Array(); 
var moves = new MoveFactory();
var props = new PropFactory();
var scene = new Phoria.Scene();
var renderer;
var predictions = [props.poi({head_color: "0,32,64", scene: scene}),props.poi({head_color: "64,0,0", scene: scene})];
var propOne = props.poi({head_color: "blue", flame_color: "blue", scene: scene});
var propTwo = props.poi({head_color: "red", flame_color: "red", scene: scene});
var startingPositions = [props.noprop({scene: scene}),props.noprop({scene: scene})];
function canvasSetup() {
	var canvas = document.getElementById("canvas");
	window.addEventListener("keydown", listenForKey, false);
	// set up Phoria scene for 3D rendering
	scene.camera.position = {x:0.0, y:1.0, z:10.0};
	scene.perspective.aspect = canvas.width / canvas.height;
	scene.viewport.width = canvas.width;
	scene.viewport.height = canvas.height;
	renderer = new Phoria.CanvasRenderer(canvas);
	var plane = Phoria.Util.generateTesselatedPlane(8,8,0,20);
	scene.graph.push(Phoria.Entity.create({
		points: plane.points,
		edges: plane.edges,
		polygons: plane.polygons,
		style: {
				 drawmode: "wireframe",
				 shademode: "plain",
				 linewidth: 0.5,
				 objectsortmode: "back"
			}}));
	scene.graph.push(new Phoria.DistantLight());
	var light = new Phoria.DistantLight();
	light.direction.x = 1;
	light.direction.z = 0;
	scene.graph.push(light);
	light = new Phoria.DistantLight();
	light.direction.y = 1;
	light.direction.z = 0;
	scene.graph.push(light);
	// set up props
	propOne.hand.radius = 1;
	propTwo.hand.radius = 1;
	propOne.rotateHand(SPLIT);
	propOne.rotateProp(SPLIT);
	myProps.push(propOne);
	myProps.push(propTwo);
	startingPositions[0].orientToProp(propOne);
	startingPositions[1].orientToProp(propTwo);
	predict();
	redraw();
}
window.addEventListener("keydown", listenForKey, false);
Prop.prototype.spinfail = function() {
	if (paused == false) {
		alert("can't spin with an empty queue");
	}
}

//**** animation and rendering
function canvasLoop() {
	if (paused == true) {return;}
	setTimeout(function() {
		requestAnimationFrame(canvasLoop);
		redraw();
		for (var i = 0; i < myProps.length; i++) {
			if (myProps[i].move.getDuration() === 0) {
				alert("Can't spin with an empty queue.");
				paused = true;
				return;
			}
		}
		advanceFrames(1);
		for (var i = 0; i < myProps.length; i++) {
			myProps[i].render();
		}
	},1000/BEAT);
}
function redraw() {
	for (var i = 0; i < myProps.length; i++) {
		predictions[i].render();
		myProps[i].render();
	}
	scene.modelView();
	renderer.render(scene);
}

//**** on load
function init() {
	$("#popexport").hide();
	$("#popimport").hide();
	populateMenu();
	canvasSetup();
}
function populateMenu() {
	var menu = $("#menu").children("select");
	var option;
	// this check helps those who save the webpage on their Desktop
	//if ($("#menu").children("select").children().toArray().length>0) {return;}
	menu.empty();
	for (var key in recipes) {
		if (key !== "add") {
			option = '<option draggable="true" ondragstart="dragMenu(event)" value="'+key+'">'+key+"</option>";
			menu.append(option);
		}
	}
}

//**** handle drag and drop events
function allowDrop(event) {
	event.preventDefault();
}
function dragMenu(event) {
	var movename = event.target.text;
	//event.dataTransfer.setData("Text", movename);
	event.dataTransfer.setData("Text", JSON.stringify(recipes[movename]));
}
function dropQueue(event) {
	event.preventDefault();
	//var movename = event.dataTransfer.getData("Text");
	//var build = JSON.stringify(recipes[movename]);
	var definition= event.dataTransfer.getData("Text");
	addMoveToQueue(definition, event.target);
}
function addMoveToQueue(definition, target) {
	var move = moves.build(definition);
	var prop;
	var queue = target.parentNode.id;
	if (queue === "queue1") {
		prop = propOne;
	} else if (queue === "queue2") {
		prop = propTwo;
	}
	//if (move.adjust(prop) != null) {
	var oriented = move.reorient(prop);
	var proceed = true;
	if (oriented === null) {
		proceed = confirm("The engine believes this move cannot be smoothly attached to the end of the current move sequence.  Do you wish to add it anyway?  Note that the engine is currently confused about contact moves and plane-bending.");
		if (proceed === true) {
			oriented = move.setAbrupt();
		}
	}
	if (proceed !== false) {
		var child = document.createElement("option");
		child.text = JSON.parse(definition).movename;
		child.value = definition;
		//child.draggable = true;
		//child.addEventListener('dragstart',drag);
		target.appendChild(child);
		prop.addMove(oriented);
		predict();
	} else {
		alert("Move not added.");
	}
	var max;
	for (var i = 0; i < myProps.length; i++) {
		max = Math.max(myProps[i].move.getDuration()*BEAT);
	}
	document.getElementById("frameN").setAttribute("max", max.toString());
	redraw();
}
function dragWorkshop(event) {
	var definition = event.target.value;
	//event.dataTransfer.setData("Text", movename);
	event.dataTransfer.setData("Text", definition);
}
function dropWorkshop(event) {
	event.preventDefault();
	var target = event.target;
	if (target.parentNode != null && target.parentNode.id === "thisMove") {target = target.parentNode;}
	var child = document.createElement("option");
	child.value = event.dataTransfer.getData("Text");
	child.text = JSON.parse(child.value).movename;
	child.draggable = true;
	child.addEventListener('dragstart',dragWorkshop);
	child.addEventListener('dragover', allowDrop);
	child.addEventListener('dblclick', modifyMove);
	target.appendChild(child);
	//document.getElementById("json").value = JSON.stringify(recipes[child.text], null, '\n');
}

//**** placeholder functionality
function nothing() {
	alert("not yet implemented");
}

var moveTarget;

function modifyMove(event) {
	moveTarget = event.target;
	$("#moveinner").empty();
	$("#movemodify").toggle();
	var definition = moves.parse(event.target.value);
	addInput(textInput(definition,"movename"));
	addInput(textInput(definition,"build"));
	addInput(selectInput(definition,"direction",["Clockwise","Counter"],[CLOCKWISE, COUNTERCLOCKWISE]));
	addInput(selectInput(definition,"orient",["Up","Right","Down","Left"],[TWELVE, THREE, SIX, NINE]));
	addInput(selectInput(definition,"entry",["Up","Right","Down","Left"],[TWELVE, THREE, SIX, NINE]));
	addInput(selectInput(definition,"hand",["Up","Right","Down","Left"],[TWELVE, THREE, SIX, NINE]));
	addInput(selectInput(definition,"spin",["In-Spin","Anti-Spin"],[INSPIN, ANTISPIN]));
	addInput(selectInput(definition,"spin1",["In-Spin","Anti-Spin"],[INSPIN, ANTISPIN]));
	addInput(selectInput(definition,"spin2",["In-Spin","Anti-Spin"],[INSPIN, ANTISPIN]));
	addInput(selectInput(definition,"bend",["Iso-Bend","Anti-Bend","Pro-Bend"],[ISOBEND, ANTIBEND, PROBEND]));
	addInput(selectInput(definition,"pitch",["Forward","Backward"],[FORWARD, BACKWARD]));
	addInput(selectInput(definition,"rescale",["Inward","Outward"],[-1, 1]));
	addInput(selectInput(definition,"petals",["Zero","One", "Two", "Three", "Four"],[0,1,2,3,4]));
	addInput(selectInput(definition,"petals1",["Zero","One", "Two", "Three", "Four"],[0,1,2,3,4]));
	addInput(selectInput(definition,"petals2",["Zero","One", "Two", "Three", "Four"],[0,1,2,3,4]));
	addInput(selectInput(definition,"harmonics",["Zero","One", "Two", "Three", "Four"],[0,1,2,3,4]));
	addInput(numberInput(definition,"extend",[0,1,0.5]));
	addInput(selectInput(definition,"mode",["Diamond","Box"],[DIAMOND, BOX]));
	addInput(selectInput(definition,"offset",["Offset","No Offset"],[OFFSET, NOOFFSET]));
	addInput(numberInput(definition,"duration",[0.25,2,0.25]));
	addInput(selectInput(definition,"pivot_angle",["Up","Right","Down","Left"],[TWELVE, THREE, SIX, NINE]));
	addInput(numberInput(definition,"pivot_radius",[0,1,0.5]));
	addInput(vectorInput(definition,"plane",["Wall","Wheel","Floor"],[WALL, WHEEL, FLOOR]));
}

function addInput(inpt) {
	if (inpt === null) {return;}
	var popup = document.getElementById("moveinner");
	var txt = document.createElement("span");
	txt.innerHTML = inpt.getAttribute("data-param")+": ";
	popup.appendChild(document.createElement("br"));
	popup.appendChild(txt);
	popup.appendChild(inpt);	
}
function textInput(definition, parameter) {
	if (definition[parameter]===undefined) {return null;}
	var inpt = document.createElement("input");
	inpt.type = "text";
	inpt.value = definition[parameter];
	inpt.setAttribute("data-param",parameter);
	return inpt;
}
function numberInput(definition, parameter, arr) {
	if (definition[parameter]===undefined) {return null;}
	var inpt = document.createElement("input");
	inpt.type = "number";
	inpt.min = arr[0].toString();
	inpt.max = arr[1].toString();
	inpt.step = arr[2].toString();
	inpt.value = definition[parameter].toString();
	inpt.setAttribute("data-param",parameter);
	return inpt;
}
function selectInput(definition, parameter, arr, vals) {
	if (definition[parameter]===undefined) {return null;}
	var inpt = document.createElement("select");
	var optn;
	for (var i = 0; i< arr.length; i++) {
		optn = document.createElement("option");
		optn.text = arr[i];
		optn.value = vals[i].toString();
		if (nearly(definition[parameter],vals[i])) {
			optn.selected = true;
		}
		inpt.appendChild(optn);
	}
	inpt.setAttribute("data-param",parameter);
	return inpt;
}

function vectorInput(definition, parameter, arr, vals) {
	if (definition[parameter]===undefined) {return null;}
	var inpt = document.createElement("select");
	var optn;
	for (var i = 0; i< arr.length; i++) {
		optn = document.createElement("option");
		optn.text = arr[i];
		optn.value = JSON.stringify(vals[i]);
		if (vals[i].nearly(definition.plane)) {
			optn.selected = true;
		}
		inpt.appendChild(optn);
	}
	inpt.setAttribute("data-param",parameter);
	return inpt;
}


function isNumber(n) {
	return !isNaN(parseFloat(n)) && isFinite(n);
}
function submitChanges() {
	var move = moveTarget;
	var olddef = moves.parse(move.value);
	var newdef = {};
	var inputs = $("#moveinner").children().toArray();
	var prmtr;
	var val;
	for (var i = 0; i < inputs.length; i++) {
		if (inputs[i] instanceof HTMLInputElement || inputs[i] instanceof HTMLSelectElement) {
			prmtr = inputs[i].getAttribute("data-param");
			if (prmtr === "plane") {
				val = JSON.parse(inputs[i].value);
				newdef[prmtr] = new Vector(val.x, val.y, val.z);
			} else {
				newdef[prmtr] = inputs[i].value;
				if (isNumber(newdef[prmtr])) {
					newdef[prmtr] = parseFloat(newdef[prmtr]);
				}
			}
		}
	}
	for (var p in newdef) {	
		olddef[p] = newdef[p];
	}
	move.value = JSON.stringify(olddef);
	move.text = olddef.movename;
	$("#movemodify").toggle();
}

// animation loop
var paused = false;
function startSpin() {
	paused = false;
	canvasLoop();
}

function pauseSpin() {
	paused = true;
}

function spinFrames(n) {
	if (n > 0) {
		pauseSpin();
		advanceFrames(n);
	} else if (n < 0) {
		var value = parseInt(document.getElementById("frameN").value);
		totalReset();
		// This nonsense is necessary because it currently sometimes spins one additional frame after resetting
		advanceFrames(value + n - parseInt(document.getElementById("frameN").value));
	}
	for (var i = 0; i < myProps.length; i++) {
		myProps[i].render();
	}
	redraw();
}

function totalReset() {
	pauseSpin();
	document.getElementById("frameN").value = "0";
	for (var i= 0; i < myProps.length; i++) {
		myProps[i].move.reset();
		myProps[i].orientToProp(startingPositions[i]);
	}
	redraw();
}

function predict() {
	predictions[0].orientToProp(propOne);
	predictions[1].orientToProp(propTwo);
	predictions[0].nudge(-0.1,0,-0.1);
	predictions[1].nudge(-0.1,0,-0.1);
}
function listenForKey(e) {
	//alert(e.keyCode);
	if (e.keyCode ===13) {
		if (document.activeElement == document.getElementById("frameN")) {
			goToFrame();
		}
	} else if (e.keyCode===37) {
		spinFrames(-12);
	} else if (e.keyCode===39) {
		spinFrames(12);
	} else if (e.keyCode==8 || e.keyCode == 46) {
		if (document.activeElement.parentNode.className=="queue") {
			document.activeElement.removeChild(document.activeElement.lastChild);
			if(document.activeElement.parentNode.id == "queue1" && propOne.move.submoves.length > 0) {
				propOne.move.submoves.pop();
			} else if (document.activeElement.parentNode.id == "queue2" && propTwo.move.submoves.length > 0) {
				propTwo.move.submoves.pop();
			}
			predict();
		} else if (document.activeElement.parentNode.id=="workshop") {
			document.activeElement.removeChild(document.activeElement.childNodes[document.activeElement.selectedIndex]);
		}
	}
}

// currently this doesn't actually check the lower bound
function checkBounds(n) {
	var max = document.getElementById("frameN").max;
	if (max==0) {
		alert("bad max input value");
		return 0;
	}
	if (n > max) {
		frameN.value = max.toString();
		while (n > max) {
			n = n-max;
		}
	} else if (n < 0) {
		alert("You entered a negative frame number and I haven't done error handling for that yet.");
	}
	return n;
}
function goToFrame() {
	var value = parseInt(document.getElementById("frameN").value);
	value = checkBounds(value);
	totalReset();
	advanceFrames(value);
	redraw();
}

function advanceFrames(n) {
	var frameN = document.getElementById("frameN");
	frameN.value = checkBounds((parseInt(frameN.value) + n)).toString();
	for (var i = 0; i < n; i++) {
		for (var j = 0;  j < myProps.length; j++) {
			myProps[j].spin();
		}
	}
}

function emptyQueues() {
	pauseSpin();
	$("#queue1 select").empty();
	$("#queue2 select").empty();
	propOne.emptyMoves();
	propTwo.emptyMoves();
	totalReset();
}

//**** functionality for JSON export/import
function popExport() {
	$("#popimport").hide();
	$("#popexport").toggle();
	var red = propOne.stringify();
	var blue = propTwo.stringify();
	$("#popexport textarea").html('{"red": '+red+', "blue": '+blue+"}");
}
function popImport() {
	$("#popexport").hide();
	$("#popimport").toggle();
}

var prop1 = "poi";
var prop2 = "poi";
var color1 = "blue";
var color2 = "red";
function popAlign(n) {
	$("#popalign"+n).toggle();
	var element;
	var angle;
	element = $('input[name=hand1]').toArray();
	angle = propOne.getHandAngle();
	for (var i = 0; i < element.length; i++) {
		if (nearly(parseFloat(element[i].value),angle)) {
			element[i].checked = true;
		} else {
			element[i].checked = false;
		}
	}
	element = $('input[name=hand2]').toArray();
	angle = propTwo.getHandAngle();
	for (var i = 0; i < element.length; i++) {
		if (nearly(parseFloat(element[i].value),angle)) {
			element[i].checked = true;
		} else {
			element[i].checked = false;;
		}
	}
	element = $('input[name=prop1]').toArray();
	angle = propOne.getPropAngle();
	for (var i = 0; i < element.length; i++) {
		if (nearly(parseFloat(element[i].value),angle)) {
			element[i].checked = true;
		} else {
			element[i].checked = false;
		}
	}
	element = $('input[name=prop2]').toArray();
	angle = propTwo.getPropAngle();
	for (var i = 0; i < element.length; i++) {
		if (nearly(parseFloat(element[i].value),angle)) {
			element[i].checked = true;
		} else {
			element[i].checked = false;
		}
	}
	element = $('input[name=pivot1]').toArray();
	angle = propOne.getPivotAngle();
	for (var i = 0; i < element.length; i++) {
		if (nearly(parseFloat(element[i].value),angle)) {
			element[i].checked = true;
		} else {
			element[i].checked = false;
		}
	}
	element = $('input[name=pivot2]').toArray();
	angle = propTwo.getPivotAngle();
	for (var i = 0; i < element.length; i++) {
		if (nearly(parseFloat(element[i].value),angle)) {
			element[i].checked = true;
		} else {
			element[i].checked = false;
		}
	}
	$("#1prop").val(prop1);
	$("#2prop").val(prop2);
	$("#1color").val(color1);
	$("#2color").val(color2);
}

function importSubmit() {
	var imported = $("#popimport textarea").val();
	imported = props.parse(imported);
	emptyQueues();
	var newoption;
	var plane;
	for (var i = 0; i < imported.red.moves.length; i++) {
		addMoveToQueue(JSON.stringify(imported.red.moves[i]), $("#queue1 select").get(0));
	}
	for (var i = 0; i < imported.blue.moves.length; i++) {
		addMoveToQueue(JSON.stringify(imported.blue.moves[i]), $("#queue2 select").get(0));
	}
	$("#popimport").toggle();
}
function alignSubmit(n) {
	var prop;
	if (n===1) {
		prop = propOne;
	} else if (n===2) {
		prop = propTwo;
	}
	prop.setHandAngle(parseFloat($('input[name=hand' + n + ']:checked').val()));
	prop.hand.radius = parseFloat(document.getElementById('hradius'+n).value);
	prop.setPropAngle(parseFloat($('input[name=prop' + n + ']:checked').val()));
	prop.setPivotAngle(parseFloat($('input[name=pivot' + n + ']:checked').val()));
	prop.pivot.radius = parseFloat(document.getElementById('pradius'+n).value);
	
	var text = document.getElementById(n+"color").value;
	var color;
	var dark;
	if (text === "red") {
		color = "red";
		dark = "64,0,0";
	} else if (text === "blue") {
		color = "blue";
		dark = "0,32,64";
	} else if (text === "yellow") {
		color = "yellow";
		dark = "64,64,0";
	} else if (text === "green") {
		color = "green";
		dark = "0,64,0";
	} else if (text === "orange") {
		color = "orange";
		dark = "64,32,0";
	} else if (text === "white") {
		color = "white";
		dark = "64,64,64";
	}
	text =  document.getElementById(n+"prop").value;
	if (n===1) {
		color1 = color;
		prop1 = text;
	} else if (n===2) {
		color2 = color;
		prop2 = text;
	}
	var renderer;
	var predicted;
	
	if (text=="poi") {
		renderer = props.poirender({head_color: color, scene: scene});
		predicted = props.poirender({head_color: dark, scene: scene});
	} else if (text=="staff") {
		renderer = props.staffrender({head_color: color, scene: scene});
		predicted = props.staffrender({head_color: dark, scene: scene});
	} else if (text=="hoop") {
		renderer = props.hooprender({head_color: color, scene: scene});
		predicted = props.hooprender({head_color: dark, scene: scene});
	} else if (text=="none") {
		renderer = props.noproprender({scene: scene});
		predicted = props.noproprender({scene: scene});
	}
	prop.renderer.deactivate();
	prop.renderer = renderer;
	prop.renderer.activate();
	predictions[n-1].renderer.deactivate();
	predictions[n-1].renderer = predicted;
	predictions[n-1].renderer.activate();
	predict();
	redraw();
	$("#popalign"+n).toggle();
}

</script>
</head>
<body onload="init();">
<header>
	<h1>Welcome to VisualSpinner3d. </h1>
	<p>(So far the dragging and dropping works only in Firefox, which makes this page unusable in other browsers.)</p>
</header>
	
<div id="content">
	<section>
		<div id="display">
			<canvas width="400" height="400" id="canvas">
				Your browser doesn't support the HTML5 element canvas.
			</canvas>
		</div>
		<div id="control">
			<button type="button" onclick="startSpin();">Play</button>
			<button type="button" onclick="pauseSpin();">Pause</button>
			<button type="button" onclick="spinFrames(-12)">-</button>
			<input id="frameN" min="0" value="0" type="number">
			<button type="button" onclick="spinFrames(12)" ;="">+</button>
			<button type="button" onclick="totalReset();">Reset Spin</button>
			<br>
			<button type="button" onclick="emptyQueues();">Reset Queues</button>
			<br>
			<button type="button" onclick="popExport();">Export to JSON</button>
			<button type="button" onclick="popImport();">Import from JSON</button>
		</div>
		<div id="queue1" class="queue">
			<h2>Blue Prop</h2>
			<button type="button" onclick="popAlign(1);">Options</button>
			<select size="2" ondrop="dropQueue(event)" ;="" ondragover="allowDrop(event);"></select>
		</div>	

		<div id="queue2" class="queue">
			<h2>Red Prop</h2>
			<button type="button" onclick="popAlign(2);">Options</button>
			<select size="2" ondrop="dropQueue(event);" ondragover="allowDrop(event);"></select>
		</div>
		
		<div id="workshop" ondrop="dropWorkshop(event);" ondragover="allowDrop(event);">
			<h2>Workshop</h2>
			<br>
			<select id="thisMove" size="2"></select>
			<button type="button" onclick="nothing();">Save</button>
		</div>
		
		<div id="menu">
			<h2>Menu</h2>
			<select size="2"></select>
		</div>				
	</section>
</div>
<div style="display: none;" id="popexport">
	<textarea rows="4" cols="50"></textarea><br>
	<button type="button" onclick="$('#popexport').toggle()">Done</button>
</div>
<div style="display: none;" id="popimport">
	<textarea rows="4" cols="50"></textarea><br>
	<button type="button" onclick="popImport();">Cancel</button>
	<button type="button" onclick="importSubmit();">Submit</button>
</div>
<div style="display: none;" id="popalign1">
		Prop:
			<select id="1prop">
				<option value="poi">Poi</option>
				<option value="staff">Staff</option>
				<option value="hoop">Hoop</option>
				<option value="none">None</option>
			</select>
		<br>
		Color:
			<select id="1color">
				<option value="red">Red</option>
				<option value="blue">Blue</option>
				<option value="yellow">Yellow</option>
				<option value="green">Green</option>
				<option value="orange">Orange</option>
				<option value="white">White</option>
			</select>
		<br>
		<br>
		<u>Starting Positions</u>
		<br>
		Hand:
				<p></p><table>
					<tbody><tr>
						<td></td>
						<td><input name="hand1" value="4.712389" type="radio">Up</td>
						<td></td>
					</tr>
					<tr>
						<td><input checked="checked" name="hand1" value="3.141593" type="radio">Left</td>
						<td><input id="hradius1" min="0" max="1" step="0.5" value="1" type="number"></td>
						<td><input name="hand1" value="0" type="radio">Right</td>
					</tr>	
					<tr>
						<td></td>
						<td><input name="hand1" value="1.570796" type="radio">Down</td>
						<td></td>
					</tr>	
				</tbody></table>	
		Prop:
				<table>
					<tbody><tr>
						<td></td>
						<td><input name="prop1" value="4.712389" type="radio">Up</td>
						<td></td>
					</tr>
					<tr>
						<td><input checked="checked" name="prop1" value="3.141593" type="radio">Left</td>
						<td></td>
						<td><input name="prop1" value="0" type="radio">Right</td>
					</tr>	
					<tr>
						<td></td>
						<td><input name="prop1" value="1.570796" type="radio">Down</td>
						<td></td>
					</tr>	
				</tbody></table>
		Pivot:
				<table>
					<tbody><tr>
						<td></td>
						<td><input name="pivot1" value="4.712389" type="radio">Up</td>
						<td></td>
					</tr>
					<tr>
						<td><input checked="checked" name="pivot1" value="3.141593" type="radio">Left</td>
						<td><input id="pradius1" min="0" max="1" step="0.5" value="0" type="number"></td>
						<td><input name="pivot1" value="0" type="radio">Right</td>
					</tr>	
					<tr>
						<td></td>
						<td><input name="pivot1" value="1.570796" type="radio">Down</td>
						<td></td>
					</tr>	
				</tbody></table>
	<button type="button" onclick="popAlign(1);">Cancel</button>
	<button type="button" onclick="alignSubmit(1);">Submit</button>
</div>
<div style="display: none;" id="popalign2">
		Prop:
			<select id="2prop">
				<option value="poi">Poi</option>
				<option value="staff">Staff</option>
				<option value="hoop">Hoop</option>
				<option value="none">None</option>
			</select>
		<br>
		Color:
			<select id="2color">
				<option value="red">Red</option>
				<option value="blue">Blue</option>
				<option value="yellow">Yellow</option>
				<option value="green">Green</option>
				<option value="orange">Orange</option>
				<option value="white">White</option>
			</select>
		<br>
		<br>
		<u>Starting Positions</u>
		<br>
		Hand:
				<p></p><table>
					<tbody><tr>
						<td></td>
						<td><input name="hand2" value="4.712389" type="radio">Up</td>
						<td></td>
					</tr>
					<tr>
						<td><input checked="checked" name="hand2" value="3.141593" type="radio">Left</td>
						<td><input id="hradius2" min="0" max="1" step="0.5" value="1" type="number"></td>
						<td><input name="hand2" value="0" type="radio">Right</td>
					</tr>	
					<tr>
						<td></td>
						<td><input name="hand2" value="1.570796" type="radio">Down</td>
						<td></td>
					</tr>	
				</tbody></table>	
		Prop:
				<table>
					<tbody><tr>
						<td></td>
						<td><input name="prop2" value="4.712389" "="" type="radio">Up</td>
						<td></td>
					</tr>
					<tr>
						<td><input checked="checked" name="prop2" value="3.141593" type="radio">Left</td>
						<td></td>
						<td><input name="prop2" value="0" type="radio">Right</td>
					</tr>	
					<tr>
						<td></td>
						<td><input name="prop2" value="1.570796" type="radio">Down</td>
						<td></td>
					</tr>	
				</tbody></table>
			Pivot:
				<table>
					<tbody><tr>
						<td></td>
						<td><input name="pivot2" value="4.712389" type="radio">Up</td>
						<td></td>
					</tr>
					<tr>
						<td><input checked="checked" name="pivot2" value="3.141593" type="radio">Left</td>
						<td><input id="pradius2" min="0" max="1" step="0.5" value="0" type="number"></td>
						<td><input name="pivot2" value="0" type="radio">Right</td>
					</tr>	
					<tr>
						<td></td>
						<td><input name="pivot2" value="1.570796" type="radio">Down</td>
						<td></td>
					</tr>	
				</tbody></table>
	<button type="button" onclick="popAlign(2);">Cancel</button>
	<button type="button" onclick="alignSubmit(2);">Submit</button>
</div>
<div style="display: none;" id="movemodify">
	<button type="button" onclick='$("#movemodify").toggle();'>Cancel</button>
	<button type="button" onclick="submitChanges();">Submit</button>
	<div id="moveinner"></div>
</div>
</body></html>