<!--Distributed under GNU Public License version 3-->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>VisualSpinner3D v. 3.0, by Glenn Wright</title>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="scripts/three.min.js"></script>
<script src="OrbitControls.js"></script>
<script src="scripts/gl-matrix-min.js"></script>
<script src="scripts/phoria-min.js"></script>
<script src="scripts/requestAnimationFrame.js"></script>
<script src="scripts/visual-spinner-engine.js"></script>
<script src="scripts/visual-spinner-moves.js"></script>
<script src="scripts/visual-spinner-ui.js"></script>
<script>

var ELEMENTS = VS3D.Constants.ELEMENTS;
var HOME = VS3D.Constants.HOME;
var HAND = VS3D.Constants.HAND;
var XAXIS = VS3D.Constants.XAXIS;
var YAXIS = VS3D.Constants.YAXIS;
var ZAXIS = VS3D.Constants.ZAXIS;
var WALL = VS3D.Constants.WALL;
var WHEEL = VS3D.Constants.WHEEL;
var FLOOR = VS3D.Constants.FLOOR;
var BEAT = VS3D.Constants.BEAT;

function ThreeJS3dRenderer() {}

ThreeJS3dRenderer.prototype.activate = function(widget) {
  var gl, experimental;
  /*try { gl = canvas.getContext("webgl"); }
  catch (x) { gl = null; }

  if (gl == null) {
      try { gl = canvas.getContext("experimental-webgl"); experimental = true; }
      catch (x) { gl = null; }
  }
  if (gl===null) {
    alert("WebGL not supported!");
  }*/
  var WIDTH = 400;
  var HEIGHT = 400;
  this.renderer = new THREE.WebGLRenderer({antialias: true});
  //this.renderer.setSize(400,400);
  this.renderer.setSize(WIDTH,HEIGHT);
  this.renderer.setClearColor(0x333F47, 1);
  var div = widget.div;
  div.removeChild(widget.canvas);
  div.removeChild(div.children[0]);
  div.appendChild(this.renderer.domElement);
  div.appendChild(document.createElement('br'));
  widget.canvas = div.children[0];

  //div.replaceChild(c1,c2);
  this.scene = new THREE.Scene();
  this.camera = new THREE.PerspectiveCamera(45, WIDTH/HEIGHT, 0.1, 20000);
  this.camera.position.set(0,6,0);
  this.scene.add(this.camera);
	this.renderer.setClearColor(0x000000,1.0);
  var light = new THREE.PointLight(0xffffff);
	light.position.set(-100,200,100);
	this.scene.add(light);
  this.props = [];
  this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
  this.renderer.render(this.scene, this.camera);
  this.controls.update();
};

ThreeJS3dRenderer.prototype.camera = function(_x,_y,_z) {
	this.camera.position = {x: _x, y: _y, z: _z};
}
ThreeJS3dRenderer.prototype.cameraX = function() {
	return this.camera.position.x;
}
ThreeJS3dRenderer.prototype.cameraY = function() {
	return this.camera.position.y;
}
ThreeJS3dRenderer.prototype.cameraZ = function() {
	return this.camera.position.z;
}
ThreeJS3dRenderer.prototype.deactivate = function(widget) {
}
ThreeJS3dRenderer.prototype.clean = function() {
	//do nothing
}
/*ThreeJS3dRenderer.prototype.render = function(scene) {
	var myProp;
	// remove any shapes that shouldn't be there
	for (var i = 0; i<scene.props.length; i++) {
		myProp = scene.props[i].prop;
		if (scene.props.indexOf(myProp)===-1) {
			for (var j = 0; j<scene.props[i].shapes.length; j++) {
        //!!!Whatever we need to do to remove old shapes
				this.scene.remove(scene.props[i].shapes[j]);
				scene.props[i] = null;
			}
		}
	}
	// clean up the prop registry
	scene.props = scene.props.filter(function (x) {return x !== null;});
	// add any shape that need adding
	var newProp;
	for (var i = 0; i < scene.props.length; i++) {
		myProp = scene.props[i];
		var found = false;
		for (var j = 0; j<this.props.length; j++) {
			if (this.props[j].prop === myProp) {
				found = true;
				break;
			}
		}
		if (found===false) {
			newProp = new ThreeJSProp(myProp);
			this.props.push(newProp);
      //!!!Whatever we need to do to add new shapes
			this.scene.remove(this.props[i].shapes[j]);
			this.props[i] = null;
		}
	}
	// rebuild any renderers whose properties have changed
	for (var i = 0; i < this.props.length; i++) {
		if (	this.props[i].propType !== this.props[i].prop.propType
				|| this.props[i].color !== this.props[i].prop.color
				||	this.props[i].fire !== this.props[i].prop.fire)	{
			for (var j = 0; j<this.props[i].shapes.length; j++) {
        //!!!
				//this.scene.graph.splice(this.scene.graph.indexOf(this.props[i].shapes[j]),1);
			}
			newProp = new ThreeJSProp(this.props[i].prop);
			this.props[i] = newProp;
      //!!!
			for (var k=0; k<newProp.shapes; k++) {
				this.scene.add(newProp.shapes[k]);
			}
		}
	}
  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	var mat;
	for (var i = 0; i < this.props.length; i++) {
		// new matrix centered on the origin
		mat = new THREE.Matrix4();
		myProp = this.props[i].prop;
		// rotate and translate according to "home", "pivot", "helper", and "hand"
		for (j = HOME; j<=HAND; j++) {
			mat.makeRotationZ(myProp[ELEMENTS[j]].azimuth);
			mat.makeRotationY(myProp[ELEMENTS[j]].zenith);
			mat.makeTranslation(0,0,myProp[ELEMENTS[j]].radius);
			mat.makeRotationY(-myProp[ELEMENTS[j]].zenith);
			mat.makeRotationZ(-myProp[ELEMENTS[j]].azimuth);
		}
		var s = myProp.prop.vectorize().rotate(myProp.bend,myProp.prop.vectorize().cross(myProp.axis)).spherify();
		// BEND
		mat.makeRotationZ(s.azimuth);
		mat.makeRotationY(s.zenith);
		// GRIP and CHOKE
		mat.makeTranslation(0,0,0.5*myProp.prop.radius);
		mat.makeRotationX(myProp.grip);
		mat.makeTranslation(0,0,(-myProp.choke-0.5)*myProp.prop.radius);
		// TWIST
		if (myProp.prop.vectorize().nearly(WALL)) {
			// handle the weird cusp
			mat.makeRotationZ(myProp.twist+WHEEL.between(myProp.axis));
		} else {
			// use the rest of the time
			mat.makeRotationZ(myProp.twist+WALL.between(myProp.axis));
		}
		for (var j = 0; j<this.props[i].shapes.length; j++) {
			this.props[i].shapes[j].matrix.copy(mat);
			// so far, poi are the only props that can change visual prop radius
			if (myProp.propType === "poi") {
				this.props[i].updatePoi(myProp);
			}
		}
	}
  this.renderer.render(this.scene, this.camera);
}*/



// add any shape that need adding

// rebuild any renderers whose properties have changed

ThreeJS3dRenderer.prototype.render = function(scene) {
  var myProp;
  // remove any shapes that shouldn't be there
  for (var i = 0; i<this.props.length; i++) {
    myProp = this.props[i].prop;
    if (scene.props.indexOf(myProp)===-1) {
      for (var j = 0; j<this.props[i].shapes.length; j++) {
        //!!!Whatever we need to do to remove old shapes
        this.scene.remove(this.props[i].shapes[j]);
        this.props[i] = null;
      }
    }
  }
  // clean up the prop registry
  this.props  = this.props.filter(function (x) {return x !== null;});
  // add any shape that need adding
  var newProp;
  for (var i = 0; i < scene.props.length; i++) {
    myProp = scene.props[i];
    var found = false;
    for (var j = 0; j<this.props.length; j++) {
      if (this.props[j].prop === myProp) {
        found = true;
        break;
      }
    }
    if (found===false) {
      newProp = new ThreeJSProp(myProp);
      this.props.push(newProp);
      for (var k=0; k<newProp.shapes.length; k++) {
        this.scene.add(newProp.shapes[k]);
      }
    }
  }
  // rebuild any renderers whose properties have changed
  for (var i = 0; i < this.props.length; i++) {
    if (	this.props[i].propType !== this.props[i].prop.propType
        || this.props[i].color !== this.props[i].prop.color
        ||	this.props[i].fire !== this.props[i].prop.fire)	{
      for (var j = 0; j<this.props[i].shapes.length; j++) {
        this.scene.remove(this.props[i].shapes[j]);
      }
      newProp = new ThreeJSProp(this.props[i].prop);
      this.props.push(newProp);
      for (var k=0; k<newProp.shapes.length; k++) {
        this.scene.add(newProp.shapes[k]);
      }
    }
  }
  var start, mat;
  var scale = 1.5;
	for (var i = 0; i < this.props.length; i++) {
		// new matrix centered on the origin
    start = new THREE.Matrix4();
		mat = new THREE.Matrix4();
		myProp = this.props[i].prop;
		// rotate and translate according to "home", "pivot", "helper", and "hand"
    for (s=0; s<this.props[i].shapes.length; s++) {
      var shape = this.props[i].shapes[s];
      shape.position.x = 0;
      shape.position.y = 0;
      shape.position.z = 0;
      shape.rotation.x = 0;
      shape.rotation.y = 0;
      shape.rotation.z = 0;
      for (j = HOME; j<=HAND; j++) {
        shape.rotateY(-myProp[ELEMENTS[j]].azimuth);
        shape.rotateX(-myProp[ELEMENTS[j]].zenith);
        shape.translateX(myProp[ELEMENTS[j]].radius);
        shape.rotateX(myProp[ELEMENTS[j]].zenith);
        shape.rotateY(myProp[ELEMENTS[j]].azimuth);
  		}
  		var s = myProp.prop.vectorize().rotate(myProp.bend,myProp.prop.vectorize().cross(myProp.axis)).spherify();
  		// BEND
      shape.rotateY(-s.azimuth);
      shape.rotateX(-s.zenith);
  		// GRIP and CHOKE
      shape.translateX(0.5*myProp.prop.radius);
      shape.rotateZ(myProp.grip);
      shape.translateX((-myProp.choke-0.5)*myProp.prop.radius);
  		// TWIST
  		if (myProp.prop.vectorize().nearly(WALL)) {
  			// handle the weird cusp
  			shape.rotateY(-myProp.twist+WHEEL.between(myProp.axis), ZAXIS);
  		} else {
  			// use the rest of the time
        shape.rotateY(-myProp.twist+WALL.between(myProp.axis), ZAXIS);
  		}
  		// so far, poi are the only props that can change visual prop radius
  		if (myProp.propType === "poi") {
  			//this.props[i].updatePoi(myProp);
  		}
  	}
	}
  this.renderer.render(this.scene, this.camera);
  this.controls.update();
}

function ThreeJSProp(myProp) {
	this.prop = myProp;
	this.propType = myProp.propType;
	this.color = myProp.color;
	this.fire = myProp.fire;
  //!!!!!Need to actually draw a poi now
  var model = new THREE.SphereGeometry(0.2,16,16);
  var material = new THREE.MeshLambertMaterial({color: this.color});
  var sphere = new THREE.Mesh(model, material);
  this.shapes = [sphere];
}
</script>
<script>
var vs;
var renderer, div, canv1, canv2;
function init() {
	vs = VS3D.VisualSpinnerWidget();
	VS3D.Constants.rescope(vs);
	vs.embedById("vs-div");
  vs.swapRenderer(new ThreeJS3dRenderer(vs));
	var propOne = vs.addProp();
	var propTwo = vs.addProp();
	propOne.color = "red";
	propTwo.color = "blue";
	propOne.hand.radius = 1;
	propTwo.hand.radius = 1;
	propOne.addMove(vs.Moves.build.flower({spin: vs.ANTISPIN}));
	propTwo.addMove(vs.Moves.build.flower({spin: vs.ANTISPIN, direction: vs.COUNTERCLOCKWISE}));
	vs.addControls("play","pause","rewind","frame","forward","reset","2d3d");
  vs.ready();
  function animate() {
    requestAnimationFrame(animate);
    vs.renderer.renderer.render(vs.renderer.scene,vs.renderer.camera);
    vs.renderer.controls.update();
  }
  animate();
}
</script>
<body onload="init();">
<a href='http://infiniteperplexity.github.io/visual-spinner-3d/'>See more at the VisualSpinner3D main site.</a>
<div id="vs-div">
</div>
</body>
</html>
