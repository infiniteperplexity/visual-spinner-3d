<!--Distributed under GNU Public License version 3-->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>VisualSpinner3D v. 3.0, by Glenn Wright</title>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="scripts/three.min.js"></script>
<script src="scripts/requestAnimationFrame.js"></script>
<script src="scripts/visual-spinner-engine.js"></script>
<script src="scripts/visual-spinner-moves.js"></script>
<script src="scripts/visual-spinner-ui.js"></script>
<script>
function ThreeJS3dRenderer() {}

ThreeJS3dRenderer.prototype.activate = function(widget) {
  var gl, experimental;
  /*try { gl = canvas.getContext("webgl"); }
  catch (x) { gl = null; }

  if (gl == null) {
      try { gl = canvas.getContext("experimental-webgl"); experimental = true; }
      catch (x) { gl = null; }
  }
  if (gl===null) {
    alert("WebGL not supported!");
  }*/
  //this.renderer = new THREE.WebGLRenderer({canvas: widget.canvas});
  this.renderer = new THREE.WebGLRenderer();
  this.scene = new THREE.Scene();
  this.camera = new THREE.PerspectiveCamera(45, widget.canvas.width/widget.canvas.height, 0.1, 20000);
	this.renderer.setClearColor(0x000000,1.0);
  var light = new THREE.PointLight(0xffffff);
	light.position.set(-100,200,100);
	this.scene.add(light);
};

ThreeJS3dRenderer.prototype.camera = function(_x,_y,_z) {
	this.camera.position = {x: _x, y: _y, z: _z};
}
ThreeJS3dRenderer.prototype.cameraX = function() {
	return this.camera.position.x;
}
ThreeJS3dRenderer.prototype.cameraY = function() {
	return this.camera.position.y;
}
ThreeJS3dRenderer.prototype.cameraZ = function() {
	return this.camera.position.z;
}
ThreeJS3dRenderer.prototype.deactivate = function(widget) {
}
ThreeJS3dRenderer.prototype.clean = function() {
	//do nothing
}
ThreeJS3dRenderer.prototype.render = function(scene) {
	var myProp;
	// remove any shapes that shouldn't be there
	for (var i = 0; i<scene.props.length; i++) {
		myProp = scene.props[i].prop;
		if (scene.props.indexOf(myProp)===-1) {
			for (var j = 0; j<scene.props[i].shapes.length; j++) {
        //!!!Whatever we need to do to remove old shapes
				this.scene.remove(scene.props[i].shapes[j]);
				scene.props[i] = null;
			}
		}
	}
	// clean up the prop registry
	scene.props = scene.props.filter(function (x) {return x !== null;});
	// add any shape that need adding
	var newProp;
	for (var i = 0; i < scene.props.length; i++) {
		myProp = scene.props[i];
		var found = false;
		for (var j = 0; j<this.props.length; j++) {
			if (this.props[j].prop === myProp) {
				found = true;
				break;
			}
		}
		if (found===false) {
			newProp = new ThreeJSProp(myProp);
			this.props.push(newProp);
      //!!!Whatever we need to do to add new shapes
			this.scene.remove(this.props[i].shapes[j]);
			this.props[i] = null;
		}
	}
	// rebuild any renderers whose properties have changed
	for (var i = 0; i < this.props.length; i++) {
		if (	this.props[i].propType !== this.props[i].prop.propType
				|| this.props[i].color !== this.props[i].prop.color
				||	this.props[i].fire !== this.props[i].prop.fire)	{
			for (var j = 0; j<this.props[i].shapes.length; j++) {
        //!!!
				//this.scene.graph.splice(this.scene.graph.indexOf(this.props[i].shapes[j]),1);
			}
			newProp = new ThreeJSProp(this.props[i].prop);
			this.props[i] = newProp;
      //!!!
			for (var k=0; k<newProp.shapes; k++) {
				this.scene.add(newProp.shapes[k]);
			}
		}
	}
  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	var mat;
	for (var i = 0; i < this.props.length; i++) {
		// new matrix centered on the origin
		mat = new THREE.Matrix4();
		myProp = this.props[i].prop;
		// rotate and translate according to "home", "pivot", "helper", and "hand"
		for (j = HOME; j<=HAND; j++) {
			mat.makeRotationZ(myProp[ELEMENTS[j]].azimuth);
			mat.makeRotationY(myProp[ELEMENTS[j]].zenith);
			mat.makeTranslation(0,0,myProp[ELEMENTS[j]].radius);
			mat.makeRotationY(-myProp[ELEMENTS[j]].zenith);
			mat.makeRotationZ(-myProp[ELEMENTS[j]].azimuth);
		}
		var s = myProp.prop.vectorize().rotate(myProp.bend,myProp.prop.vectorize().cross(myProp.axis)).spherify();
		// BEND
		mat.makeRotationZ(s.azimuth);
		mat.makeRotationY(s.zenith);
		// GRIP and CHOKE
		mat.makeTranslation(0,0,0.5*myProp.prop.radius);
		mat.makeRotationX(myProp.grip);
		mat.makeTranslation(0,0,(-myProp.choke-0.5)*myProp.prop.radius);
		// TWIST
		if (myProp.prop.vectorize().nearly(WALL)) {
			// handle the weird cusp
			mat.makeRotationZ(myProp.twist+WHEEL.between(myProp.axis));
		} else {
			// use the rest of the time
			mat.makeRotationZ(myProp.twist+WALL.between(myProp.axis));
		}
		for (var j = 0; j<this.props[i].shapes.length; j++) {
			this.props[i].shapes[j].matrix.copy(mat);
			// so far, poi are the only props that can change visual prop radius
			if (myProp.propType === "poi") {
				this.props[i].updatePoi(myProp);
			}
		}
	}
  this.renderer(this.scene, this.camera)
}

function ThreeJSProp(myProp) {
	this.prop = myProp;
	this.propType = myProp.propType;
	this.color = myProp.color;
	this.fire = myProp.fire;
  //!!!!!Need to actually draw a poi now
  var model = new THREE.SphereGeometry();
  var material = new THREE.MeshLambertMaterial({color: color});
  this.shapes = [new THREE.Mesh(model, material)];
}
</script>
<script>
var vs;
function init() {
	vs = VS3D.VisualSpinnerWidget();
  vs.swapRenderer(new ThreeJS3dRenderer(vs));
	VS3D.Constants.rescope(vs);
	vs.embedById("vs-div");
	var propOne = vs.addProp();
	var propTwo = vs.addProp();
	propOne.color = "red";
	propTwo.color = "blue";
	propOne.hand.radius = 1;
	propTwo.hand.radius = 1;
	propOne.addMove(vs.Moves.build.flower({spin: vs.ANTISPIN}));
	propTwo.addMove(vs.Moves.build.flower({spin: vs.ANTISPIN, direction: vs.COUNTERCLOCKWISE}));
	vs.addControls("play","pause","rewind","frame","forward","reset","2d3d");
	vs.ready();
}
</script>
<body onload="init();">
<a href='http://infiniteperplexity.github.io/visual-spinner-3d/'>See more at the VisualSpinner3D main site.</a>
<div id="vs-div">
</div>
</body>
</html>
