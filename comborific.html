<!--Distributed under GNU Public License version 3-->
<!DOCTYPE html>
<html><head>
<style>
body {margin: 0; padding: 0; background-color: #679}
h1, h2, header p {text-align: center}
header {width: 1240px; height: 100px}
#content {width: 1250px; height: 510px;}
canvas {width: 400px; height: 400px; background-color: #000;}
section {margin: 0; padding: 0}
header, section div {vertical-align: top; padding: 2.5px; border: 5px solid gray; margin: -2.5px; display: inline-block;}
#display {width: 400px; height: 400px; float: left}
#popimport {height: 240px; width: 400px}
</style>


<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>VisualSpinner3D Player, by Glenn Wright</title>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="scripts/gl-matrix-min.js"></script>
<script src="scripts/phoria-min.js"></script>
<script src="scripts/requestAnimationFrame.js"></script>
<script src="scripts/visual-spinner-engine.js"></script>
<script src="scripts/visual-spinner-moves.js"></script>
<script src="scripts/visual-spinner-renderers.js"></script><script>
// set parameters

var HEIGHT = 400;
var WIDTH = 400;
var ORIGINX = WIDTH/2;
var ORIGINY = HEIGHT/2;
var BACKGROUND = "black";

var view2d = false;

var myProps = new Array(); 
var moves = new MoveFactory();
var props = new PropFactory();

function init() {
	ctx=document.getElementById('canvas').getContext('2d');
	if( 	navigator.userAgent.match(/Android/i)
		|| navigator.userAgent.match(/webOS/i)
		|| navigator.userAgent.match(/iPhone/i)
		|| navigator.userAgent.match(/iPad/i)
		|| navigator.userAgent.match(/iPod/i)
		|| navigator.userAgent.match(/BlackBerry/i)
		|| navigator.userAgent.match(/Windows Phone/i)) {
		$("#2d3d").val("2d");
	} else {
		$("#2d3d").val("3d");
	}
	canvasSetup();
	canvasLoop();
}

var scene = new Phoria.Scene();
var renderer;
var orangePoi = props.poi({head_color: "orange", scene: scene});
var whitePoi = props.poi({head_color: "white", scene: scene});
function canvasSetup() {
	var prop = new Prop();
	var link = new MoveLink();
	var angle = SIX;
	canvas.height = HEIGHT;
	canvas.width = WIDTH;
	ctx.fillStyle = BACKGROUND;
	ctx.strokeStyle = BACKGROUND;
	ctx.fillRect(0,0,WIDTH,HEIGHT);
	
	// set up Phoria scene for 3D rendering
	scene.camera.position = {x:0.0, y:1.0, z:10.0};
	scene.perspective.aspect = canvas.width / canvas.height;
	scene.viewport.width = canvas.width;
	scene.viewport.height = canvas.height;
	renderer = new Phoria.CanvasRenderer(canvas);
	var plane = Phoria.Util.generateTesselatedPlane(8,8,0,20);
	scene.graph.push(Phoria.Entity.create({
		points: plane.points,
		edges: plane.edges,
		polygons: plane.polygons,
		style: {
				 drawmode: "wireframe",
				 shademode: "plain",
				 linewidth: 0.5,
				 objectsortmode: "back"
			}}));
	scene.graph.push(new Phoria.DistantLight());
	var light = new Phoria.DistantLight();
	light.direction.x = 1;
	light.direction.z = 0;
	scene.graph.push(light);
	light = new Phoria.DistantLight();
	light.direction.y = 1;
	light.direction.z = 0;
	scene.graph.push(light);
	// set up props
	orangePoi.hand.radius = 1;
	whitePoi.hand.radius = 0;
	orangePoi.rotateHand(SPLIT);
	orangePoi.rotateProp(SPLIT);
	whitePoi.rotateHand(SPLIT);
	whitePoi.rotateProp(SPLIT);
	myProps.push(orangePoi);
	myProps.push(whitePoi);

	// Drex begins with a counterclockwise pendulum vs. extended pendulum hybrid.
		// Note the use of "hybrid: true" on the extended pendulum.
			// This tells the hand speed the smooth path of the other pendulum's prop
			// The default (hybrid: false) instead spins at a constant speed that will match a static spin or flower
			// Note that the constant THREE, SIX, NINE, and TWELVE refer to the clock points (directions)
		// Pendulum paths are not true to real-world gravity, because I use a simplified function
	orangePoi.addMove(moves.pendulum({hybrid: true, direction: COUNTERCLOCKWISE, extend: 1, duration: 0.5, entry: NINE}));
	whitePoi.addMove(moves.pendulum({direction: COUNTERCLOCKWISE, extend: 0, duration: 0.5, entry: NINE}));
	
	// Next Drex does a clockwise pendulum vs. antispin hybrid.  
		// My library of moves doesn't have a method to build flowers whose hand speed follows a pendulum...
		// ...so I use the convenient "splice" method to splice the hand path of a hybrid pendulum onto an antispin flower
	orangePoi.addMove(moves.flower({spin: ANTISPIN, duration: 0.5}).splice({hand: moves.pendulum({hybrid: true, duration: 0.5, entry: THREE})}));
	whitePoi.addMove(moves.pendulum({extend: 0, duration: 0.5, entry: THREE}));
	
	// Back to the original hybrid...
	orangePoi.addMove(moves.pendulum({hybrid: true, direction: COUNTERCLOCKWISE, extend: 1, duration: 0.5, entry: NINE}));
	whitePoi.addMove(moves.pendulum({direction: COUNTERCLOCKWISE, extend: 0, duration: 0.5, entry: NINE}));
	
	// ...and back to the second, spliced hybrid
	orangePoi.addMove(moves.flower({spin: ANTISPIN, duration: 0.5}).splice({hand: moves.pendulum({hybrid: true, duration: 0.5, entry: THREE})}));
		// As Drex transitions to the next move, he distorts the second half of the hybrid in various ways
			// The orange poi stops and reverses direction (much more slowly) and the hand holding it drifts to the right
	orangePoi.tail().prop.speed = -1; orangePoi.tail().prop.acc = 0; orangePoi.tail().hand.stretch = -2;
	whitePoi.addMove(moves.pendulum({direction: CLOCKWISE, extend: 0, duration: 0.5, entry: THREE}));
			// The white poi drifts to the right so Drex can spin moves that are not centered on his body
				// VisualSpinner handles this sort of thing using the "pivot" element to recenter the move
	whitePoi.tail().pivot.stretch = 2;
	
	// The next move is point isolation vs. static spin.  A point isolation can be modeled as a box-mode, zero-petal, in-spin flower.
	orangePoi.addMove(moves.flower({petals: 0, pivot_angle: THREE, pivot_radius: 0.5, duration: 0.5}));
	whitePoi.addMove(moves.staticspin({hand: THREE, extend: 0.5, duration: 0.5}));
	
	// The next move is isolation vs. vertical cateye
	orangePoi.addMove(moves.isolation({spin: CATEYE, pivot_angle: THREE, pivot_radius: 1, duration: 1.25}));
	whitePoi.addMove(moves.isolation({entry: NINE, pivot_angle: THREE, pivot_radius: 1, duration: 1.25}));
	
	// Then Drex spins a single antispin petal with the orange poi while recentering the poi on his body
	orangePoi.addMove(moves.flower({spin: ANTISPIN, extend: 0.5, duration: 0.25, pivot_angle: THREE, pivot_radius: 1}));
	orangePoi.tail().pivot.stretch = -2; orangePoi.tail().hand.stretch = 4;
	// The next white poi move is a little ambiguous...it's sort of a little half-pendulum that ends up recentered.
		// The "generic" move template starts with a motionless prop and lets you hard-code any parameters you want to change.
		// It's useful to handling weird little transitions like this.
	whitePoi.addMove(moves.generic({pivot_angle: THREE, pivot_radius: 1, prop_speed: 1, prop_acc : -4, hand_angle: TWELVE, hand_radius: 0.5, hand_stretch: -1, pivot_stretch: -2, duration: 0.5}));
	
	// Next comes static spin vs. extension.
	orangePoi.addMove(moves.flower({direction: COUNTERCLOCKWISE, petals: 0, duration: 1}));
	whitePoi.addMove(moves.staticspin({direction: COUNTERCLOCKWISE, duration: 0.75}));
	
	// Next comes pendulum vs. overhead CAP
	orangePoi.addMove(moves.ccap({orient: TWELVE, direction: COUNTERCLOCKWISE, phase: 1}));
	whitePoi.addMove(moves.pendulum({direction: CLOCKWISE, extend:0, entry: NINE, duration: 1}));
	// Then repeat the same hybrid
	orangePoi.addMove(moves.ccap({orient: TWELVE, direction: COUNTERCLOCKWISE, phase: 1}));
	whitePoi.addMove(moves.pendulum({direction: CLOCKWISE, extend:0, entry: NINE, duration: 1}));
	// Then one quarter of a repetition
	orangePoi.addMove(moves.ccap({orient: TWELVE, direction: COUNTERCLOCKWISE, phase: 1, duration: 0.25}));
	whitePoi.addMove(moves.pendulum({direction: CLOCKWISE, extend:0, entry: NINE, duration: 0.25}));
	// The white poi drifts down to prepare for the next move
	whitePoi.tail().hand.angle = SIX; whitePoi.tail().hand.speed = 0; whitePoi.tail().hand.stretch = 4; whitePoi.tail().hand.direction = COUNTERCLOCKWISE;
	
	// The next move is a split pair of linear isolations
		// These have oval hand paths, and the engine is currently very messy with those
		// We use "pivot" to do it ad hoc
		// Also, MoveLinks probably shouldn't get realigned like this
	orangePoi.addFixedMove(moves.generic({hand_linear_angle: SIX, hand_linear_speed: 2, prop_speed: -1.5, duration: 0.5, pivot_entry: NINE, pivot_stretch: 1}));
	whitePoi.addFixedMove(moves.generic({hand_linear_angle: TWELVE, hand_linear_speed: 2, prop_speed: -1.5, duration: 0.5, pivot_entry: THREE, pivot_stretch: 1}));
	orangePoi.addFixedMove(moves.generic({hand_linear_angle: SIX, hand_linear_speed: 2, prop_speed: -1.5, duration: 0.5, pivot_entry: NINE, pivot_stretch: -1}));
	whitePoi.addFixedMove(moves.generic({hand_linear_angle: TWELVE, hand_linear_speed: 2, prop_speed: -1.5, duration: 0.5, pivot_entry: THREE, pivot_stretch: -1}));
	// Next set
	orangePoi.addFixedMove(moves.generic({hand_linear_angle: TWELVE, hand_linear_speed: 2, prop_speed: -1.5, duration: 0.5, pivot_entry: THREE, pivot_stretch: 1}));
	whitePoi.addFixedMove(moves.generic({hand_linear_angle: SIX, hand_linear_speed: 2, prop_speed: -1.5, duration: 0.5, pivot_entry: NINE, pivot_stretch: 1}));
	orangePoi.addFixedMove(moves.generic({hand_linear_angle: TWELVE, hand_linear_speed: 2, prop_speed: -1.5, duration: 0.5, pivot_entry: THREE, pivot_stretch: -1}));
	whitePoi.addFixedMove(moves.generic({hand_linear_angle: SIX, hand_linear_speed: 2, prop_speed: -1.5, duration: 0.5, pivot_entry: NINE, pivot_stretch: -1}));
	// Half a set
	orangePoi.addFixedMove(moves.generic({hand_linear_angle: SIX, hand_linear_speed: 2, prop_speed: -1.5, duration: 0.5, pivot_entry: NINE, pivot_stretch: 1}));
	whitePoi.addFixedMove(moves.generic({hand_linear_angle: TWELVE, hand_linear_speed: 2, prop_speed: -1.5, duration: 0.5, pivot_entry: THREE, pivot_stretch: 1}));
	// Transition
	orangePoi.addMove(moves.isolation({direction: COUNTERCLOCKWISE, entry: NINE, duration: 0.25}));
	whitePoi.addMove(moves.isolation({direction: COUNTERCLOCKWISE, entry: THREE, duration: 0.25}));
	//  Triquetra vs. Anti-pendulum
		// The anti-pendulum in this combo has several weird properities
			// The top half pivots upward and then drops back down
			// It also doesn't swing as far as a normal pendulum
		// The easiest approach turned out to be to add an "antibrid" parameter to the method
	orangePoi.addMove(moves.flower({spin: ANTISPIN, petals: 3, extend: 0.5, entry: TWELVE, mode: DIAMOND, pivot_angle: SIX, pivot_radius: 1}));
	whitePoi.addMove(moves.pendulum({antibrid: true, spin: ANTISPIN, direction: COUNTERCLOCKWISE, entry: TWELVE, extend: 0.5, pivot_angle: SIX, pivot_radius: 0.5}));
	// Repeat once
	orangePoi.addMove(moves.flower({spin: ANTISPIN, petals: 3, extend: 0.5, entry: TWELVE, mode: DIAMOND, pivot_angle: SIX, pivot_radius: 1}));
	whitePoi.addMove(moves.pendulum({antibrid: true, spin: ANTISPIN, direction: COUNTERCLOCKWISE, entry: TWELVE, extend: 0.5, pivot_angle: SIX, pivot_radius: 0.5}));
	// Half of one more repetition
	orangePoi.addMove(moves.flower({spin: ANTISPIN, petals: 3, extend: 0.5, entry: TWELVE, mode: DIAMOND, pivot_angle: SIX, pivot_radius: 1, duration: 0.5}));
	whitePoi.addMove(moves.pendulum({antibrid: true, spin: ANTISPIN, direction: COUNTERCLOCKWISE, entry: TWELVE, extend: 0.5, pivot_angle: SIX, pivot_radius: 0.5, duration: 0.5}));
	
	redraw();
}

Prop.prototype.spinfail = function() {
	alert("can't spin with an empty queue");
}

// animation loop
function canvasLoop() {
	setTimeout(function() {
		requestAnimationFrame(canvasLoop);
		redraw();
		for (var i = 0; i < myProps.length; i++) {
			myProps[i].spin();
			myProps[i].render();
		}
	},1000/BEAT);
}
function redraw() {
	for (var i = 0; i < myProps.length; i++) {
		myProps[i].render();
	}
	if (view2d == true) {
		ctx.fillStyle = "rgba(0,0,0,0.01)";
		ctx.strokeStyle=BACKGROUND;
		ctx.fillRect(0,0,WIDTH,HEIGHT);
	}
	else {
		scene.modelView();
		renderer.render(scene);
	}
}

</script>
</head>
<body onload="init();">
<header>
	<h1>Welcome to VisualSpinner3d. </h1>
	<p>(we have successfully digitized Drex.)</p>
</header>
	
<div id="display">
	<canvas width="400" height="400" id="canvas">
		Your browser doesn't support the HTML5 element canvas.
	</canvas>
</div>
</body></html>